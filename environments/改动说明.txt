v: 观测数据为场数据
v2: 观测数据调整为井的  含水+压力 (
v3：观测数据改为井所在位置网格的 气体饱和度，含水饱和度，压力 （wbp9)
v4: 观测数据改成井所在周围一定范围内网格的 气体饱和度，含水饱和度 和压力 的平均值




q: 只优化注采量
p: 只优化新井，每一步是添加一口新井 （保证新井数和步数匹配）
q+t: 优化注采量和井类型
qtp模式：优化注采量和井别，同时初始化的时候添加了随机井位
q+t+p+t+v :优化注采量+井类型转换+新井位置 + 开井先后 + 新井类型（h水平井，v直井）
1！注意带P之前的版本只针对老井，没有新井, 
2而且pt的在这种模式下，因为井是不断添加的，因此v2-v4这种由井点生成的state就很难实现


#切换模式的时候需要注意的几个问题
0 首先要在main函数开头改变环境名子
1、state_dim 要使用可迭代方式
2、注意切换网络的第一层 conv或者mlp
3 如果没有新井，需要设置总井数=老井，且 新井数=0
4、action数量要等于总井数
5 不改变井别时，需要控制量的最小值》=0
6 对于不包含tv的模式下，state dim 的永久系数是3，包括了sat, pres以及step_num
7 使用multiprocessing 时，调用的类内方法有条件 1,该方法不能带有任何的log性质文件作为其内部属性，例如open（）和tensorboard 。2不能使用函数内嵌的函数
8！！使用random seed的时候，就固定了random的顺序，每一次重新设置seed就相当于重新设置了顺序. 所以为env设置的seed要每次reset都给一次，这样 才能保证每次的env reset结果是一致的
np.random.seed(1)
print(np.random.randn(3,))
np.random.seed(1)
print(np.random.randn(3,))
print(np.random.randn(3,))
==》[ 1.62434536 -0.61175641 -0.52817175]
[ 1.62434536 -0.61175641 -0.52817175]
[-1.07296862  0.86540763 -2.3015387 ]